# INTRO

[[exercises]]
name = "intro1"
path = "exercises/intro/intro1.rs"
mode = "compile"
hint = """
删除文件 exercises/intro/intro1.rs 中的注释 I AM NOT DONE
以前往下一个练习。"""

[[exercises]]
name = "intro2"
path = "exercises/intro/intro2.rs"
mode = "compile"
hint = """
在格式化字符串后添加一个参数。"""

# VARIABLES

[[exercises]]
name = "variables1"
path = "exercises/variables/variables1.rs"
mode = "compile"
hint = """
第8行的声明语句遗漏了一个关键字，Rust需要用使用它
来创建一个新的变量绑定。"""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2.rs"
mode = "compile"
hint = """
编译器信息说 Rust 根据给定的信息无法推断变量 `x` 绑定的变量的类型。
如果你在第7行加上类型注解会发生什么？
如果你给 x 一个值呢？
如果你两个都做呢？
不管怎样，x 应该是什么类型的？
如果 x 和 10 是同一个类型会怎样？如果不是同一个类型会怎样？"""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3.rs"
mode = "compile"
hint = """
哎呀！在这个练习中，我们在第7行创建了一个变量绑定，
并且尝试在第8行使用，但是我们没有给它一个值。
我们无法打印一个不存在的东西；尝试给 x 一个值！
这是一个在任何编程语言中都很容易犯的会导致 bug 的错误 -- 感谢 Rust 编译器为我们捕获了它！"""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4.rs"
mode = "compile"
hint = """
在 Rust 中，变量绑定默认是不可变的。但是这里我们尝试重新赋给 x 一个不同的值！
作为替代，有一个关键字让我们将变量设置为可变的。"""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5.rs"
mode = "compile"
hint = """
在练习 variables4 中我们已经学习了如果使用特定关键字将一个不可变变量设为可变变量。
不幸的是，这在这个练习中没有帮助，因为我们想要赋一个不同类型的值给一个已存在的变量。
有时你可能也想重复使用已经存在的变量名因为你想要像这个练习一样只想要将其以不同类型的值覆盖。
幸运的是，Rust 在这个问题上有一个强大的解决方案： 'Shadowing'（'遮蔽'）！
你可以在书本的章节
'变量和可变性' https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing
（译者注：中文版本 https://rustwiki.org/zh-CN/book/ch03-01-variables-and-mutability.html#%E9%81%AE%E8%94%BD）
中阅读到更多关于 'Shadowing' 的内容。
然后尝试使用这项技术来解决这个练习吧。"""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6.rs"
mode = "compile"
hint = """
我们知道了变量和可变性，但是这里还有另一种重要类型的可用变量：常量。
常量总是不可变的，并且它们以关键字 'const' 而不是关键字 'let' 进行声明。
常量的类型也必须总是被注解。

通过在书本的章节 '变量和可变性' 的 
'常量' 小节 https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants
（译者注：中文版本 https://rustwiki.org/zh-CN/book/ch03-01-variables-and-mutability.html#%E5%B8%B8%E9%87%8F）
阅读更多关于常量以及其与变量的不同。
"""

# FUNCTIONS

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1.rs"
mode = "compile"
hint = """
这个主程序正在调用一个期待存在的函数，但是这个函数不存在。
它希望这个函数有一个名字 `call_me`。
它希望这个函数不接受任何参数，也不返回值。
这听起来很像 `main` 函数，不是吗？"""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2.rs"
mode = "compile"
hint = """
Rust 要求函数签名的所有部分都有类型注解，
但是 `call_me` 缺少了 `num` 的类型注解。"""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3.rs"
mode = "compile"
hint = """
这一次，函数 *声明* 是好的，但是在调用函数的地方有一些问题。
提示一下，在 Rustlings 中你可以自由使用不同地方案！
观察模式只会在你删除注释 I AM NOT DONE 之后跳转到下一个练习。"""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4.rs"
mode = "compile"
hint = """
错误信息指向了第17行并说它期待在 `->` 之后有一个类型。
这是函数的返回值类型应处的位置 -- 看一下示例函数 `is_even`！

同样的：你是否有注意到，技术上，这里 u32 会是更适合价格的类型，因为它们不能为负数？
如果是这样的话，那就太好了！"""

[[exercises]]
name = "functions5"
path = "exercises/functions/functions5.rs"
mode = "compile"
hint = """
这是一个非常常见的错误，可以通过删除一个字符解决。
这是因为 Rust 区分了表达式和语句：表达式基于其操作返回一个值，而语句则返回一个 () 类型，其行为与 C/C++ 中的 `void`类似。
它们不是同一个东西。有两种解决方法：
1. 在 `num * num;` 之前添加一个 `return`
2. 删除 `;`，使其变为 `num * num`"""

# IF

[[exercises]]
name = "if1"
path = "exercises/if/if1.rs"
mode = "test"
hint = """
如果你想要的话，只用一行来完成是可行的！
一些来自其它语言的相似例子：
- 在 C(++) 中这会是： `a > b ? a : b`
- 在 Python 中这会是： `a if a > b else b`
记住在 Rust 中：
- if 判别式不需要被圆括号包含
- `if`/`else` 是表达式
- 每个判别式后跟一个 `{}` 块"""

[[exercises]]
name = "if2"
path = "exercises/if/if2.rs"
mode = "test"
hint = """
对于第一个编译器错误，Rust 中每个条件分支都需要返回相同的类型！
为了使测试通过，你需要使用多个条件分支来判断不同的输入。"""

# QUIZ 1

[[exercises]]
name = "quiz1"
path = "exercises/quiz1.rs"
mode = "test"
hint = "这次没有提示 ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1.rs"
mode = "compile"
hint = "这次没有提示 ;)"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2.rs"
mode = "compile"
hint = "这次没有提示 ;)"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3.rs"
mode = "compile"
hint = """
有一个根据确切大小来初始化数组的快捷方法，这样你就不用写100个值了（当然你也可以这样做！）。
比如，你可以：
let array = ["Are we there yet?"; 10];
另外：关于 `a.len() >= 100` 你还能使用什么其它方式实现吗？"""

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4.rs"
mode = "test"
hint = """
通过阅读以下文章来认识 所有权 -> 切片 -> 其它切片
https://doc.rust-lang.org/book/ch04-03-slices.html
https://rustwiki.org/zh-CN/book/ch04-03-slices.html（中文版，译者注）
并且使用你想要的起始和结束索引获取数组切片。

如果你很好奇为什么 `assert_eq!` 第二个参数是一个引用但是第一个参数不需要加上 & 号来作为引用
的话，阅读以下关于强制转换的文档：
https://doc.rust-lang.org/nomicon/coercions.html"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5.rs"
mode = "compile"
hint = """
看一下书本的 数据类型 -> 元组类型 章节：
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
https://rustwiki.org/zh-CN/book/ch03-02-data-types.html#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B（中文版，译者注）
特别是关于解构的部分（此章节的倒数第二个例子）。
你需要使用模式绑定 `name` 和 `age` 到元组的相应部分。
你可以做到的！！"""

[[exercises]]
name = "primitive_types6"
path = "exercises/primitive_types/primitive_types6.rs"
mode = "test"
hint = """
这里你可以使用 `let` 解构一个元组，尝试一下使用索引来替代吧，
这在书本的 数据类型 -> 元组类型 章节的最后一个例子中可以看到解释：
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
https://rustwiki.org/zh-CN/book/ch03-02-data-types.html#%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B（中文版，译者注）
现在你的工具箱中又多一件工具了！"""

# VECS

[[exercises]]
name = "vecs1"
path = "exercises/vecs/vecs1.rs"
mode = "test"
hint = """
在 Rust 中，有两种方法定义一个 Vector。
1. 第一种方式是使用 `Vec::new()` 函数来创建一个新的vector，
   并通过 `push()` 方法填充它。
2. 第二种方式更简单一点，使用 `vec![]` 宏并在方括号中定义你的元素。
详见 Rust 书的这个章节：https://doc.rust-lang.org/stable/book/ch08-01-vectors.html
https://rustwiki.org/zh-CN/book/ch08-01-vectors.html（中文版，译者注）
"""

[[exercises]]
name = "vecs2"
path = "exercises/vecs/vecs2.rs"
mode = "test"
hint = """
提示1：`i` 迭代为 Vec 的每个元素。你可以乘它吗？

提示2：在第一函数中，有一个方法直接访问 Vec 中存储的数字，
那就是使用 * 解引用操作符。以这种方式你可以访问和写入数字。

当你完成了两个函数后，自行决定你喜欢的的方式。
你觉得 Rust 开发者最常用的模式是什么？
"""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics1"
path = "exercises/move_semantics/move_semantics1.rs"
mode = "compile"
hint = """
所以你在第13行获得了错误 "cannot borrow immutable local variable `vec1` as mutable"
（无法借用不可变本地变量 `vec1` 为可变的），对吗？
修复方法是添加一个关键字，不过不是添加到出现错误的第13行。

另外：尝试在调用 `fill_vec()` 之后访问 `vec0`，看看会发生什么！"""

[[exercises]]
name = "move_semantics2"
path = "exercises/move_semantics/move_semantics2.rs"
mode = "compile"
hint = """
那么，`vec0` 作为一个参数传入了 `fill_vec` 函数。在 Rust 中，
当一个参数被传入一个函数且没有被明确地返回时，
你再也不能使用原始变量。我们把这叫做 "moving(移动)" 一个变量。
被移动到函数（或块域）并且没有被明确返回的变量会在函数的末尾
被 "dropped"。这里发生的也是这样的事情。
有几种方法可以修复它，如果你想的话可以试一下：
1. 制作另一个包含 `vec0` 中的数据的版本并将其传入到 `fill_vec`。
2. 使 `fill_vec` 借用它的参数而不是获取其所有权，
   然后在函数中复制它的数据以返回一个自己的 `Vec<i32>`
3. 使 `fill_vec` *可变地* 借用它参数的一个引用（这个参数也需要是可变的），
   直接修改它，然后不要返回任何东西。这样你就可以完全摆脱 `vec1` 了 -- 注意
   这将会改变第一个 `println!` 的打印结果"""

[[exercises]]
name = "move_semantics3"
path = "exercises/move_semantics/move_semantics3.rs"
mode = "compile"
hint = """
这一个练习和上一个的区别是 `fn fill_vec` 的第一行现在没有 `let mut vec = vec;` 了。
你可以，不要添加回那一行，而是在某个地方添加 `mut` 来改变一个已有的绑定，
将其由不可变改为可变绑定 :)"""

[[exercises]]
name = "move_semantics4"
path = "exercises/move_semantics/move_semantics4.rs"
mode = "compile"
hint = """
停止阅读一旦你觉得你有足够的方向了 :) 或者尝试
执行一个步骤然后修复其导致的编译器错误！
所以最终目标是：
   - 去掉 main 函数中创建一个新的 vector 的第一行
   - 然后 `vec0` 就不存在了，所以我们不能将其传入 `fill_vec` 中
   - 我们不想往 `fill_vec` 中传入任何东西，所以它的签名需要反映它不需要传入任何参数
   - 因为我们不再在 `main` 中创建一个新的 vec，我们需要在 `fill_vec` 中创建
     一个新的 vec，就像我们在 `main` 中做的那样"""

[[exercises]]
name = "move_semantics5"
path = "exercises/move_semantics/move_semantics5.rs"
mode = "compile"
hint = """
仔细分析关于每个可变引用在作用域中的范围。
在获取可变引用之后，直接改变 (x) 的值是否有帮助？
在书本的 引用和借用 章节的 “可变引用” 阅读更多关于 “可变引用” 的内容：
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references.
https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8（中文版，译者注）
"""

[[exercises]]
name = "move_semantics6"
path = "exercises/move_semantics/move_semantics6.rs"
mode = "compile"
hint = """
为了找到答案，你可以查阅书本章节 “引用和借用”：
https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html
https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html（中文版，译者注）
第一个问题是，`get_char` 获取了字符串的所有权。
所以 `data` 被移动了并且不能再被 `string_uppercase` 使用
`data` 先是被移动到 `get_char`，意味着 `string_uppercase` 不能操作这个数据了。
一旦你修复了它，`string_uppercase` 的函数签名也需要被适配。
你能想出办法吗？

另一个提示：它需要使用 `&` 符号。"""

# STRUCTS

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1.rs"
mode = "test"
hint = """
Rust 不止一种结构体。事实上，三种，所有类型都是用来将有关联的数据包裹在一起。
这里有普通的（或经典的）结构体。这些是存储在相应字段的数据的集合。
元组结构体基本上就叫做元组。
最后是类单元结构体。它们没有字段，在泛型上很有用。

在这个练习中你需要完成并实现其中一种类型。
在书本中阅读更多关于结构体的内容：
https://doc.rust-lang.org/book/ch05-01-defining-structs.html
https://rustwiki.org/zh-CN/book/ch05-00-structs.html（中文版，译者注）"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2.rs"
mode = "test"
hint = """
创建一个结构体示例是非常简单的，你所需要做的就是给它的字段赋值。
不过也有一些实例化结构体的捷径。
看一下书本，并发现更多：https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
https://rustwiki.org/zh-CN/book/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B（中文版，译者注）"""

[[exercises]]
name = "structs3"
path = "exercises/structs/structs3.rs"
mode = "test"
hint = """
对于 is_international：是什么让一个包裹国际化？看起来与它去的地方有关系对吗？

对于 get_fees：这个方法传入一个额外参数，Package 结构体中有一个与它有关系的字段吗？

看一下书本来找到更多关于方法实现的内容：https://doc.rust-lang.org/book/ch05-03-method-syntax.html
https://rustwiki.org/zh-CN/book/ch05-03-method-syntax.html（中文版，译者注）"""

# ENUMS

[[exercises]]
name = "enums1"
path = "exercises/enums/enums1.rs"
mode = "compile"
hint = "这次没有提示 ;)"

[[exercises]]
name = "enums2"
path = "exercises/enums/enums2.rs"
mode = "compile"
hint = """
你可以创建拥有不同类型的不同值的枚举，比如说无数据、匿名结构、一个字符串、元组，等等"""

[[exercises]]
name = "enums3"
path = "exercises/enums/enums3.rs"
mode = "test"
hint = """
第一步，你可以添加枚举以使代码可以无错误编译。
然后在 `process()` 中创建一个匹配表达式。
注意有些消息变量你需要在匹配表达式中进行结构，以得到变量中的值。"""

# STRINGS

[[exercises]]
name = "strings1"
path = "exercises/strings/strings1.rs"
mode = "compile"
hint = """
`current_favorite_color` 函数现在返回了一个字符串切片，这个切片的声明周期为 `'static`。
我们知道这一点是因为字符串存在于我们的代码本省 -- 它不来自于文件或用户输入或其它程序 -- 所以
它将随着我们的程序存在。但是它仍然使一个字符串切片。有个通过转换字符串切片来创建一个 `String` 的方法，
它在书本的 字符串 章节，还有一个方法是使用 `From` trait。"""

[[exercises]]
name = "strings2"
path = "exercises/strings/strings2.rs"
mode = "compile"
hint = """
是的，有个很容易修复这个 bug 的方法，那就是改变 `word` 绑定的值为一个字符串切片而不是一个 `String`， 不是吗？
不过也有另一个方法，那就是在第 9 行添加一个字符，这会强制转换 `String` 为一个字符串切片。"""

[[exercises]]
name = "strings3"
path = "exercises/strings/strings3.rs"
mode = "test"
hint = """
有成吨的关于字符串的标准库函数。
让我们试一下吧：<https://doc.rust-lang.org/std/string/struct.String.html#method.trim>！

对于 compose_me 方法：你可以使用 `format!` 宏，或者将一个字符串切片转换为原始字符串，
这样你就可以自由扩展它了。"""

[[exercises]]
name = "strings4"
path = "exercises/strings/strings4.rs"
mode = "compile"
hint = "这次没有提示 ;)"

# MODULES

[[exercises]]
name = "modules1"
path = "exercises/modules/modules1.rs"
mode = "compile"
hint = """
Rust 中所有东西默认都是私有(private)的 -- 但是我们可以通过一个参数使一些变为公共的(public)！
编译器的错误应该指向了一个需要变为公共的(public)东西。"""

[[exercises]]
name = "modules2"
path = "exercises/modules/modules2.rs"
mode = "compile"
hint = """
delicious_snacks 模块正在试图对外呈现一个接口，其不同于
它的内部结构（`fruits` 和 `veggies` 模块以及相关常量）。完成 `use` 语句
以修复 main 中的调用并找到两个常量都缺失的一个关键字。"""

[[exercises]]
name = "modules3"
path = "exercises/modules/modules3.rs"
mode = "compile"
hint = """
UNIX_EPOCH 和 SystemTime 被声明于 std::time 模块。使用一个 use 语句以将
这俩引入作用域。你可以使用嵌套路径或者 glob 运算符，这样就可以只用一行就将它们都引入。"""

# HASHMAPS

[[exercises]]
name = "hashmaps1"
path = "exercises/hashmaps/hashmaps1.rs"
mode = "test"
hint = """
提示1：看一下函数的返回值类型并推导出 `basket` 的类型。
提示2：水果的个数应至少为5。并且你必须放入至少三种水果。
"""

[[exercises]]
name = "hashmaps2"
path = "exercises/hashmaps/hashmaps2.rs"
mode = "test"
hint = """
使用哈希表的 `entry()` 和 `or_insert()` 方法来完成这个练习。
了解更多：https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#only-inserting-a-value-if-the-key-has-no-value
（中文版，译者注）https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E5%8F%AA%E5%9C%A8%E9%94%AE%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E6%97%B6%E6%8F%92%E5%85%A5
"""

[[exercises]]
name = "hashmaps3"
path = "exercises/hashmaps/hashmaps3.rs"
mode = "test"
hint = """
提示1：使用哈希表的 `entry()` 和 `or_insert()` 方法在得分表中插入与每个团队对应的条目。
提示2：如果给定键已经有了一个条目，则 `entry()` 返回的值可以基于已存在的值进行更新。
了解更多：https://doc.rust-lang.org/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value
（中文版，译者注）https://rustwiki.org/zh-CN/book/ch08-03-hash-maps.html#%E6%A0%B9%E6%8D%AE%E6%97%A7%E5%80%BC%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E5%80%BC
"""

# QUIZ 2

[[exercises]]
name = "quiz2"
path = "exercises/quiz2.rs"
mode = "test"
hint = "这次没有提示 ;)"

# OPTIONS

[[exercises]]
name = "options1"
path = "exercises/options/options1.rs"
mode = "test"
hint = """
Option 可以有一个含内部值的 Some 值，或者一个不含内部值的 None。
有很多方法可以获取内部值，你可以使用 unwrap，或模式匹配。
Unwrap 是最简单的，但是你要怎么安全地使用它以避免它以后在你面前发生 panic？"""

[[exercises]]
name = "options2"
path = "exercises/options/options2.rs"
mode = "test"
hint = """
check out:
https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html

Remember that Options can be stacked in if let and while let.
For example: Some(Some(variable)) = variable2
Also see Option::flatten
"""

[[exercises]]
name = "options3"
path = "exercises/options/options3.rs"
mode = "compile"
hint = """
The compiler says a partial move happened in the `match`
statement. How can this be avoided? The compiler shows the correction
needed. After making the correction as suggested by the compiler, do
read: https://doc.rust-lang.org/std/keyword.ref.html"""

# ERROR HANDLING

[[exercises]]
name = "errors1"
path = "exercises/error_handling/errors1.rs"
mode = "test"
hint = """
`Ok` and `Err` are one of the variants of `Result`, so what the tests are saying
is that `generate_nametag_text` should return a `Result` instead of an
`Option`.

To make this change, you'll need to:
   - update the return type in the function signature to be a Result<String, String> that
     could be the variants `Ok(String)` and `Err(String)`
   - change the body of the function to return `Ok(stuff)` where it currently
     returns `Some(stuff)`
   - change the body of the function to return `Err(error message)` where it
     currently returns `None`"""

[[exercises]]
name = "errors2"
path = "exercises/error_handling/errors2.rs"
mode = "test"
hint = """
One way to handle this is using a `match` statement on
`item_quantity.parse::<i32>()` where the cases are `Ok(something)` and
`Err(something)`. This pattern is very common in Rust, though, so there's
a `?` operator that does pretty much what you would make that match statement
do for you! Take a look at this section of the Error Handling chapter:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator
and give it a try!"""

[[exercises]]
name = "errors3"
path = "exercises/error_handling/errors3.rs"
mode = "compile"
hint = """
If other functions can return a `Result`, why shouldn't `main`? It's a fairly common
convention to return something like Result<(), ErrorType> from your main function.
The unit (`()`) type is there because nothing is really needed in terms of positive
results."""

[[exercises]]
name = "errors4"
path = "exercises/error_handling/errors4.rs"
mode = "test"
hint = """
`PositiveNonzeroInteger::new` is always creating a new instance and returning an `Ok` result.
It should be doing some checking, returning an `Err` result if those checks fail, and only
returning an `Ok` result if those checks determine that everything is... okay :)"""

[[exercises]]
name = "errors5"
path = "exercises/error_handling/errors5.rs"
mode = "compile"
hint = """
There are two different possible `Result` types produced within `main()`, which are
propagated using `?` operators. How do we declare a return type from `main()` that allows both?

Under the hood, the `?` operator calls `From::from` on the error value to convert it to a boxed
trait object, a `Box<dyn error::Error>`. This boxed trait object is polymorphic, and since all
errors implement the `error::Error` trait, we can capture lots of different errors in one "Box"
object.

Check out this section of the book:
https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

Read more about boxing errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html

Read more about using the `?` operator with boxed errors:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "errors6"
path = "exercises/error_handling/errors6.rs"
mode = "test"
hint = """
This exercise uses a completed version of `PositiveNonzeroInteger` from
errors4.

Below the line that TODO asks you to change, there is an example of using
the `map_err()` method on a `Result` to transform one type of error into
another. Try using something similar on the `Result` from `parse()`. You
might use the `?` operator to return early from the function, or you might
use a `match` expression, or maybe there's another way!

You can create another function inside `impl ParsePosNonzeroError` to use
with `map_err()`.

Read more about `map_err()` in the `std::result` documentation:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

# Generics

[[exercises]]
name = "generics1"
path = "exercises/generics/generics1.rs"
mode = "compile"
hint = """
Vectors in Rust make use of generics to create dynamically sized arrays of any type.
You need to tell the compiler what type we are pushing onto this vector."""

[[exercises]]
name = "generics2"
path = "exercises/generics/generics2.rs"
mode = "test"
hint = """
Currently we are wrapping only values of type 'u32'.
Maybe we could update the explicit references to this data type somehow?

If you are still stuck https://doc.rust-lang.org/stable/book/ch10-01-syntax.html#in-method-definitions
"""

# TRAITS

[[exercises]]
name = "traits1"
path = "exercises/traits/traits1.rs"
mode = "test"
hint = """
A discussion about Traits in Rust can be found at:
https://doc.rust-lang.org/book/ch10-02-traits.html
"""

[[exercises]]
name = "traits2"
path = "exercises/traits/traits2.rs"
mode = "test"
hint = """
Notice how the trait takes ownership of 'self',and returns `Self`.
Try mutating the incoming string vector. Have a look at the tests to see
what the result should look like!

Vectors provide suitable methods for adding an element at the end. See
the documentation at: https://doc.rust-lang.org/std/vec/struct.Vec.html"""

[[exercises]]
name = "traits3"
path = "exercises/traits/traits3.rs"
mode = "test"
hint = """
Traits can have a default implementation for functions. Structs that implement
the trait can then use the default version of these functions if they choose not
implement the function themselves.

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations
"""

[[exercises]]
name = "traits4"
path = "exercises/traits/traits4.rs"
mode = "test"
hint = """
Instead of using concrete types as parameters you can use traits. Try replacing the
'??' with 'impl <what goes here?>'

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters
"""

[[exercises]]
name = "traits5"
path = "exercises/traits/traits5.rs"
mode = "compile"
hint = """
To ensure a parameter implements multiple traits use the '+ syntax'. Try replacing the
'??' with 'impl <> + <>'.

See the documentation at: https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax
"""

# QUIZ 3

[[exercises]]
name = "quiz3"
path = "exercises/quiz3.rs"
mode = "test"
hint = """
To find the best solution to this challenge you're going to need to think back to your
knowledge of traits, specifically Trait Bound Syntax -  you may also need this: `use std::fmt::Display;`."""

# TESTS

[[exercises]]
name = "tests1"
path = "exercises/tests/tests1.rs"
mode = "test"
hint = """
You don't even need to write any code to test -- you can just test values and run that, even
though you wouldn't do that in real life :) `assert!` is a macro that needs an argument.
Depending on the value of the argument, `assert!` will do nothing (in which case the test will
pass) or `assert!` will panic (in which case the test will fail). So try giving different values
to `assert!` and see which ones compile, which ones pass, and which ones fail :)"""

[[exercises]]
name = "tests2"
path = "exercises/tests/tests2.rs"
mode = "test"
hint = """
Like the previous exercise, you don't need to write any code to get this test to compile and
run. `assert_eq!` is a macro that takes two arguments and compares them. Try giving it two
values that are equal! Try giving it two arguments that are different! Try giving it two values
that are of different types! Try switching which argument comes first and which comes second!"""

[[exercises]]
name = "tests3"
path = "exercises/tests/tests3.rs"
mode = "test"
hint = """
You can call a function right where you're passing arguments to `assert!` -- so you could do
something like `assert!(having_fun())`. If you want to check that you indeed get false, you
can negate the result of what you're doing using `!`, like `assert!(!having_fun())`."""

# LIFETIMES

[[exercises]]
name = "lifetimes1"
path = "exercises/lifetimes/lifetimes1.rs"
mode = "compile"
hint = """
Let the compiler guide you. Also take a look at the book if you need help:
https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"""

[[exercises]]
name = "lifetimes2"
path = "exercises/lifetimes/lifetimes2.rs"
mode = "compile"
hint = """
Remember that the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y.
You can take at least two paths to achieve the desired result while keeping the inner block:
1. Move the string2 declaration to make it live as long as string1 (how is result declared?)
2. Move println! into the inner block"""

[[exercises]]
name = "lifetimes3"
path = "exercises/lifetimes/lifetimes3.rs"
mode = "compile"
hint = """
If you use a lifetime annotation in a struct's fields, where else does it need to be added?"""

# STANDARD LIBRARY TYPES

[[exercises]]
name = "iterators1"
path = "exercises/iterators/iterators1.rs"
mode = "compile"
hint = """
Step 1:
We need to apply something to the collection `my_fav_fruits` before we start to go through
it. What could that be? Take a look at the struct definition for a vector for inspiration:
https://doc.rust-lang.org/std/vec/struct.Vec.html.
Step 2 & step 3:
Very similar to the lines above and below. You've got this!
Step 4:
An iterator goes through all elements in a collection, but what if we've run out of
elements? What should we expect here? If you're stuck, take a look at
https://doc.rust-lang.org/std/iter/trait.Iterator.html for some ideas.
"""

[[exercises]]
name = "iterators2"
path = "exercises/iterators/iterators2.rs"
mode = "test"
hint = """
Step 1
The variable `first` is a `char`. It needs to be capitalized and added to the
remaining characters in `c` in order to return the correct `String`.
The remaining characters in `c` can be viewed as a string slice using the
`as_str` method.
The documentation for `char` contains many useful methods.
https://doc.rust-lang.org/std/primitive.char.html

Step 2
Create an iterator from the slice. Transform the iterated values by applying
the `capitalize_first` function. Remember to collect the iterator.

Step 3.
This is surprising similar to the previous solution. Collect is very powerful
and very general. Rust just needs to know the desired type."""

[[exercises]]
name = "iterators3"
path = "exercises/iterators/iterators3.rs"
mode = "test"
hint = """
The divide function needs to return the correct error when even division is not
possible.

The division_results variable needs to be collected into a collection type.

The result_with_list function needs to return a single Result where the success
case is a vector of integers and the failure case is a DivisionError.

The list_of_results function needs to return a vector of results.

See https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect for how
the `FromIterator` trait is used in `collect()`. This trait is REALLY powerful! It
can make the solution to this exercise infinitely easier."""

[[exercises]]
name = "iterators4"
path = "exercises/iterators/iterators4.rs"
mode = "test"
hint = """
In an imperative language, you might write a for loop that updates
a mutable variable. Or, you might write code utilizing recursion
and a match clause. In Rust you can take another functional
approach, computing the factorial elegantly with ranges and iterators.

Hint 2: Check out the `fold` and `rfold` methods!"""

[[exercises]]
name = "iterators5"
path = "exercises/iterators/iterators5.rs"
mode = "test"
hint = """
The documentation for the std::iter::Iterator trait contains numerous methods
that would be helpful here.

Return 0 from count_collection_iterator to make the code compile in order to
test count_iterator.

The collection variable in count_collection_iterator is a slice of HashMaps. It
needs to be converted into an iterator in order to use the iterator methods.

The fold method can be useful in the count_collection_iterator function.

For a further challenge, consult the documentation for Iterator to find
a different method that could make your code more compact than using fold."""

# THREADS

[[exercises]]
name = "threads1"
path = "exercises/threads/threads1.rs"
mode = "compile"
hint = """
`JoinHandle` is a struct that is returned from a spawned thread:
https://doc.rust-lang.org/std/thread/fn.spawn.html

A challenge with multi-threaded applications is that the main thread can
finish before the spawned threads are completed.
https://doc.rust-lang.org/book/ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles

Collect the JoinHandles and wait for them to finish.
https://doc.rust-lang.org/std/thread/struct.JoinHandle.html
"""

[[exercises]]
name = "threads2"
path = "exercises/threads/threads2.rs"
mode = "compile"
hint = """
`Arc` is an Atomic Reference Counted pointer that allows safe, shared access
to **immutable** data. But we want to *change* the number of `jobs_completed`
so we'll need to also use another type that will only allow one thread to
mutate the data at a time. Take a look at this section of the book:
https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct
and keep reading if you'd like more hints :)


Do you now have an `Arc` `Mutex` `JobStatus` at the beginning of main? Like:
`let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));`
Similar to the code in the example in the book that happens after the text
that says "We can use Arc<T> to fix this.". If not, give that a try! If you
do and would like more hints, keep reading!!


Make sure neither of your threads are holding onto the lock of the mutex
while they are sleeping, since this will prevent the other thread from
being allowed to get the lock. Locks are automatically released when
they go out of scope.

If you've learned from the sample solutions, I encourage you to come
back to this exercise and try it again in a few days to reinforce
what you've learned :)"""

[[exercises]]
name = "threads3"
path = "exercises/threads/threads3.rs"
mode = "compile"
hint = """
An alternate way to handle concurrency between threads is to use
a mpsc (multiple producer, single consumer) channel to communicate.
With both a sending end and a receiving end, it's possible to
send values in one thread and receive them in another.
Multiple producers are possible by using clone() to create a duplicate
of the original sending end.
See https://doc.rust-lang.org/book/ch16-02-message-passing.html for more info.
"""

# SMART POINTERS

[[exercises]]
name = "box1"
path = "exercises/smart_pointers/box1.rs"
mode = "test"
hint = """
Step 1
The compiler's message should help: since we cannot store the value of the actual type
when working with recursive types, we need to store a reference (pointer) to its value.
We should, therefore, place our `List` inside a `Box`. More details in the book here:
https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes

Step 2
Creating an empty list should be fairly straightforward (hint: peek at the assertions).
For a non-empty list keep in mind that we want to use our Cons "list builder".
Although the current list is one of integers (i32), feel free to change the definition
and try other types!
"""

[[exercises]]
name = "rc1"
path = "exercises/smart_pointers/rc1.rs"
mode = "compile"
hint = """
This is a straightforward exercise to use the Rc<T> type. Each Planet has
ownership of the Sun, and uses Rc::clone() to increment the reference count of the Sun.
After using drop() to move the Planets out of scope individually, the reference count goes down.
In the end the sun only has one reference again, to itself. See more at:
https://doc.rust-lang.org/book/ch15-04-rc.html

* Unfortunately Pluto is no longer considered a planet :(
"""

[[exercises]]
name = "arc1"
path = "exercises/smart_pointers/arc1.rs"
mode = "compile"
hint = """
Make `shared_numbers` be an `Arc` from the numbers vector. Then, in order
to avoid creating a copy of `numbers`, you'll need to create `child_numbers`
inside the loop but still in the main thread.

`child_numbers` should be a clone of the Arc of the numbers instead of a
thread-local copy of the numbers.

This is a simple exercise if you understand the underlying concepts, but if this
is too much of a struggle, consider reading through all of Chapter 16 in the book:
https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html
"""

[[exercises]]
name = "cow1"
path = "exercises/smart_pointers/cow1.rs"
mode = "compile"
hint = """
Since the vector is already owned, the `Cow` type doesn't need to clone it.

Checkout https://doc.rust-lang.org/std/borrow/enum.Cow.html for documentation
on the `Cow` type.
"""

# MACROS

[[exercises]]
name = "macros1"
path = "exercises/macros/macros1.rs"
mode = "compile"
hint = """
When you call a macro, you need to add something special compared to a
regular function call. If you're stuck, take a look at what's inside
`my_macro`."""

[[exercises]]
name = "macros2"
path = "exercises/macros/macros2.rs"
mode = "compile"
hint = """
Macros don't quite play by the same rules as the rest of Rust, in terms of
what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus
"where you use it" actually matters."""

[[exercises]]
name = "macros3"
path = "exercises/macros/macros3.rs"
mode = "compile"
hint = """
In order to use a macro outside of its module, you need to do something
special to the module to lift the macro out into its parent.

The same trick also works on "extern crate" statements for crates that have
exported macros, if you've seen any of those around."""

[[exercises]]
name = "macros4"
path = "exercises/macros/macros4.rs"
mode = "compile"
hint = """
You only need to add a single character to make this compile.
The way macros are written, it wants to see something between each
"macro arm", so it can separate them.

That's all the macro exercises we have in here, but it's barely even
scratching the surface of what you can do with Rust's macros. For a more
thorough introduction, you can have a read through the little book of Rust
macros: https://veykril.github.io/tlborm/"""

#  CLIPPY

[[exercises]]
name = "clippy1"
path = "exercises/clippy/clippy1.rs"
mode = "clippy"
hint = """
Rust stores the highest precision version of any long or infinite precision
mathematical constants in the Rust standard library.
https://doc.rust-lang.org/stable/std/f32/consts/index.html

We may be tempted to use our own approximations for certain mathematical constants,
but clippy recognizes those imprecise mathematical constants as a source of
potential error.
See the suggestions of the clippy warning in compile output and use the
appropriate replacement constant from std::f32::consts..."""

[[exercises]]
name = "clippy2"
path = "exercises/clippy/clippy2.rs"
mode = "clippy"
hint = """
`for` loops over Option values are more clearly expressed as an `if let`"""

[[exercises]]
name = "clippy3"
path = "exercises/clippy/clippy3.rs"
mode = "clippy"
hint = "这次没有提示！"

# TYPE CONVERSIONS

[[exercises]]
name = "using_as"
path = "exercises/conversions/using_as.rs"
mode = "test"
hint = """
Use the `as` operator to cast one of the operands in the last line of the
`average` function into the expected return type."""

[[exercises]]
name = "from_into"
path = "exercises/conversions/from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `From` implementation"""

[[exercises]]
name = "from_str"
path = "exercises/conversions/from_str.rs"
mode = "test"
hint = """
The implementation of FromStr should return an Ok with a Person object,
or an Err with an error if the string is not valid.

This is almost like the `from_into` exercise, but returning errors instead
of falling back to a default value.

Look at the test cases to see which error variants to return.

Another hint: You can use the `map_err` method of `Result` with a function
or a closure to wrap the error from `parse::<usize>`.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html
"""

[[exercises]]
name = "try_from_into"
path = "exercises/conversions/try_from_into.rs"
mode = "test"
hint = """
Follow the steps provided right before the `TryFrom` implementation.
You can also use the example at https://doc.rust-lang.org/std/convert/trait.TryFrom.html

Is there an implementation of `TryFrom` in the standard library that
can both do the required integer conversion and check the range of the input?

Another hint: Look at the test cases to see which error variants to return.

Yet another hint: You can use the `map_err` or `or` methods of `Result` to
convert errors.

Yet another hint: If you would like to propagate errors by using the `?`
operator in your solution, you might want to look at
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html

Challenge: Can you make the `TryFrom` implementations generic over many integer types?"""

[[exercises]]
name = "as_ref_mut"
path = "exercises/conversions/as_ref_mut.rs"
mode = "test"
hint = """
Add AsRef<str> as a trait bound to the functions."""
